<p>
  <img src="https://i.redditmedia.com/WwwR2BqWjHcRI_Q0t--6eZemKUhE5He6cCPNJiNDUu4.jpg?w=320&s=df24e8d2232df5664b7c493e7cb1842a" style="width: 200px;" />
</p>
 
<blockquote>
  <p>Government Currencies on the Ethereum Blockchain</p>
  <p>DC assets are backed by government currency deposits providing users with a stable and secure method for storing capital on the Ethereum blockchain</p>
  <p>DC provides real-time proof of reserves that will always match what is publicly verifiable on the Ethereum blockchain</p>
  <p>DC maintains full-reserves ensuring that our digital assets can always be exchanged for the underlying currency that they represent</p>
  <p>DC is the most affordable way to bring value onto the Ethereum network</p>
  <footer><a href="https://www.decentralizedcapital.com" target="_blank">https://www.decentralizedcapital.com</a></footer>
</blockquote>---
title: Android
---

An [example application](https://github.com/UnifiedPush/android-example) is available to show basic usage of the library.

## Index

{{<toc>}}

## Install Library

Add the following two code snippets to your corresponding build files to include the library in your project.

Add the jitpack repo to the **project level** build.gradle:

```gradle
allprojects {
    repositories {
        // ...
        maven { url 'https://jitpack.io' }
    }
}
```

Add the dependency to the **app** build.gradle. Replace {VERSION} with the release you wish to use

```gradle
dependencies {
    // ...
    implementation 'com.github.UnifiedPush:android-connector:{VERSION}'
}
```

## Register for Push

{{< tabs "registration" >}}
{{< tab "Kotlin" >}}
To register for receiving push services you have two options:
1. Have the library handle distributor selection

```kotlin
val up = Registration()
// Call the library function
up.registerAppWithDialog(context)
```

2. Handle selection yourself

```kotlin
val up = Registration()
// Check if a distributor is already registered
if (up.getDistributor(context).isNotEmpty()) {
    // Re-register in case something broke
    up.registerApp(context)
    return
}
// Get a list of distributors that are available
val distributors = up.getDistributors(context)
// select one or show a dialog or whatever
val userDistrib = yourFunc(distributors)
// save the distributor
up.saveDistributor(context, userDistrib)
// register your app to the distributor
up.registerApp(context)
```

**unregister**

```kotlin
// inform the library that you would like to unregister from receiving push messages
up.unregisterApp(context)
```

**Multi-connection app**
You may need multiple connections for your app, you will need to use, as above, the following functions:
- `up.registerAppWithDialog(context, instance)`
- `up.registerApp(context, instance)`
- `up.unregisterApp(context, instance)`

{{< /tab >}}
{{< tab "Java" >}}
To register for receiving push services you have two options:

1. Have the library handle distributor selection
```java
// Call the library function
Registration up = new Registration();
up.registerAppWithDialog(context);
```

2. Handle selection yourself
```java
Registration up = new Registration();
// Check if a distributor is already registered
if (!up.getDistributor(context).isEmpty()) {
    // Re-register in case something broke
    up.registerApp(context);
    return;
}
// Get a list of distributors that are available
List<String> distributors = up.getDistributors(context);
// select one or show a dialog or whatever
String userDistrib = yourFunc(distributors);
// the below line will crash the app if no distributors are available
up.saveDistributor(context, userDistrib);
up.registerApp(context);
```

**unregister**
```java
// inform the library that you would like to unregister from receiving push messages
up.unregisterApp(context);
```

**Multi-connection app**

You may need multiple connections for your app, you will need to use, as above, the following functions:
- `up.registerAppWithDialog(context, instance);`
- `up.registerApp(context, instance);`
- `up.unregisterApp(context, instance);`
{{< /tab >}}
{{< /tabs >}}

## Receiving Push Messages

To receive Push Messages you should extend the class _MessagingReceiver_ and implement the 5 following methods:

{{< tabs "Receiver" >}}
{{< tab "Kotlin" >}}

```kotlin
val handler = object: MessagingReceiverHandler{
    override fun onMessage(context: Context?, message: String, instance: String) {
        // Called when a new message is received. The String contains the full POST body of the push message
    }

    override fun onNewEndpoint(context: Context?, endpoint: String, instance: String) {
        // Called when a new endpoint be used for sending push messages
    }
    
    override fun onRegistrationFailed(context: Context?, instance: String) {
        // called when the registration is not possible, eg. no network
    }
    
    override fun onRegistrationRefused(context: Context?, instance: String) {
        // called when the registration is refused, eg. an application with the same Id and another token is registered
    }
    
    override fun onUnregistered(context: Context?, instance: String){
        // called when this application is unregistered from receiving push messages
    }
}

class CustomReceiver: MessagingReceiver(handler)
```
{{< /tab >}}
{{< tab "Java" >}}
```java
class handler implements MessagingReceiverHandler {
    @Override
    public void onNewEndpoint(@Nullable Context context, @NotNull String endpoint, @NotNull String instance) {
        // Called when a new endpoint be used for sending push messages
    }

    @Override
    public void onRegistrationFailed(@Nullable Context context, @NotNull String instance) {
        // called when the registration is not possible, eg. no network
    }

    @Override
    public void onRegistrationRefused(@Nullable Context context, @NotNull String instance) {
        // called when the registration is refused, eg. an application with the same Id and another token is registered
    }

    @Override
    public void onUnregistered(@Nullable Context context, @NotNull String instance) {
        // called when this application is unregistered from receiving push messages
    }

    @Override
    public void onMessage(@Nullable Context context, @NotNull String message, @NotNull String instance) {
        // Called when a new message is received. The String contains the full POST body of the push message
    }
}

class CustomReceiver extends MessagingReceiver {
    public CustomReceiver() {
        super(new handler());
    }
}
```
{{< /tab >}}
{{< /tabs >}}

You will also need to declare the receiver in your manifest:

```xml
      <receiver android:exported="true"  android:enabled="true"  android:name=".CustomReceiver">
          <intent-filter>
              <action android:name="org.unifiedpush.android.connector.MESSAGE"/>
              <action android:name="org.unifiedpush.android.connector.UNREGISTERED"/>
              <action android:name="org.unifiedpush.android.connector.NEW_ENDPOINT"/>
              <action android:name="org.unifiedpush.android.connector.REGISTRATION_FAILED"/>
              <action android:name="org.unifiedpush.android.connector.REGISTRATION_REFUSED"/>
          </intent-filter>
      </receiver>
```

## Sending Push Messages

(From the application server)

To send a message to an application you need the "endpoint". You get it in the onNewEndpoint method once it is available. You can then use it to send a message using for example curl. The POST body is the message received by the function onMessage.

```bash
curl -X POST "$endpoint" --data "Any message body that is desired."
```

## Application With Embedded Distributor

Please refer to [Embedded FCM Distributor](/developers/embedded_fcm/) for more information.
